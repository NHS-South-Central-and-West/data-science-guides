---
title: "Deep Learning in Python"
author: "Paul Johnson"
date: today
---

Deep learning is a subset of machine learning that uses neural networks to learn from data. Neural networks are a type of machine learning model that are inspired by the way the human brain works. Neural networks are made up of neurons, which are connected together in layers. Each neuron receives input from the previous layer, performs a calculation, and passes the output to the next layer. The output of the final layer is the prediction of the neural network.

Neural networks are trained by adjusting the weights of the connections between neurons. The weights are adjusted based on the error of the prediction. The error is calculated by comparing the prediction to the actual value. The error is then used to adjust the weights in a way that reduces the error in the next prediction. This process is repeated until the neural network is able to make accurate predictions.

This notebook will demonstrate how to build a neural network using PyTorch to classify images of COVID-19 lung CT scans.

This notebook will take a while to run locally, unless you have a GPU. In order to run this code locally a sample of the data is taken instead. However, if you want to run this notebook using all the data, you can use [Google Colab](https://colab.research.google.com/), which provides free access to a GPU.

## Setup
```{python}
#| label: imports

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import torch
import torch.nn.functional as F

from random import sample
from shutil import copy
from torchvision import datasets, transforms
from torch import nn, optim

```

## Data

The data for this notebook is from a large public COVID-19 lung CT scan dataset, containing a total of 8,439 CT scans which consists of 7,495 positive cases (COVID-19 infection) and 944 negative ones (normal and non-COVID-19). The data is stored in a folder structure, where each folder contains images of a particular class. The folder names are the class labels.

The data is available on [Kaggle](https://www.kaggle.com/datasets/mehradaria/covid19-lung-ct-scans).

```{python}
#| label: import-data

data_dir = '../../../data/ct-scans/'

transform = transforms.Compose([
    transforms.Resize(255),
    transforms.CenterCrop(224),
    transforms.ToTensor()
    ])

dataset = datasets.ImageFolder(data_dir, transform=transform)

dataloader = torch.utils.data.DataLoader(dataset, batch_size=32, shuffle=True)

```

### Data Exploration

Because the data is stored in a folder structure, we cannot inspect the data in typical ways, like using `head()` or `describe()`. Instead, we can visualize the images themselves to get a sense of what the data looks like.

Below is a simple helper function to visualize images. We can use this function to visualize a batch of images from the training set.

```{python}
#| label: imgshow-helper

%matplotlib inline

def imgshow(image, ax=None, title=None, normalize=True):
    """Imgshow for Tensor."""
    if ax is None:
        fig, ax = plt.subplots()
    image = image.numpy().transpose((1, 2, 0))

    if normalize:
        mean = np.array([0.5, 0.5, 0.5])
        std = np.array([0.5, 0.5, 0.5])
        image = std * image + mean
        image = np.clip(image, 0, 1)

    ax.imshow(image)
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    ax.spines['left'].set_visible(False)
    ax.spines['bottom'].set_visible(False)
    ax.tick_params(axis='both', length=0)
    ax.set_xticklabels('')
    ax.set_yticklabels('')

    return ax

```

```{python}
#| label: visualize-images

# obtain one batch of training images
images, labels = next(iter(dataloader))

# plot 20 images in the batch, along with the corresponding labels
fig = plt.figure(figsize=(25, 4))
for idx in np.arange(20):
    ax = fig.add_subplot(2, 10, idx+1, xticks=[], yticks=[])
    imgshow(images[idx], normalize=False, ax=ax)
    ax.set_title(labels[idx].item())

```

```{python}
#| label: class-labels

# check how many images are in each class
print('Number of images in each class:')
print('COVID-19: ', len(os.listdir(data_dir + 'covid/')))
print('Normal: ', len(os.listdir(data_dir + 'normal/')))

```

```{python}
#| label: image-shape

# check the shape of the images
images[0].shape

```

```{python}
#| label: image-pixels

# check how many pixels are in each image
images[0].shape[1] * images[0].shape[2]

```

### Sample Data

If you want to run this notebook locally, you will need to sample the data to speed up training.

```{python}
#| label: sample-data

# get the number of images in each class
covid_count = len(os.listdir(data_dir + 'covid/'))
normal_count = len(os.listdir(data_dir + 'normal/'))

# get the number of images to sample from each class
covid_sample = int(covid_count * 0.1)
normal_sample = int(normal_count * 0.1)

# get the list of images in each class
covid_images = os.listdir(data_dir + 'covid/')
normal_images = os.listdir(data_dir + 'normal/')
covid_images = [data_dir + 'covid/' + img for img in covid_images]
normal_images = [data_dir + 'normal/' + img for img in normal_images]

# sample the images
covid_images = sample(covid_images, covid_sample)
normal_images = sample(normal_images, normal_sample)

# create a new folder to store the sampled images
sample_dir = data_dir + 'sample/'
os.mkdir(sample_dir)
os.mkdir(sample_dir + 'covid/')
os.mkdir(sample_dir + 'normal/')
covid_sample_dir = sample_dir + 'covid/'
normal_sample_dir = sample_dir + 'normal/'

# copy the sampled images to the new folder
for img in covid_images:
    copy(img, covid_sample_dir)

for img in normal_images:
    copy(img, normal_sample_dir)

```

Having sampled the data, we can now load this smaller dataset into a `DataLoader` object.

```{python}
#| label: import-sample-data

data_dir = '../../../data/ct-scans/sample/'

transform = transforms.Compose([
    transforms.Resize(255),
    transforms.CenterCrop(224),
    transforms.ToTensor()
    ])

dataset = datasets.ImageFolder(data_dir, transform=transform)

dataloader = torch.utils.data.DataLoader(dataset, batch_size=32, shuffle=True)
```

## Neural Network

The model is a simple neural network with 7 fully connected layers. The input layer has 50,176 neurons, one for each pixel in the image. The output layer has 2 neurons, one for each class. The hidden layers have 512, 256, 128, 64, 32, and 16 neurons, respectively. The model uses dropout to prevent overfitting.

```{python}
#| label: specify-model

class Classifier(nn.Module):
    def __init__(self):
        super().__init__()
        self.fc1 = nn.Linear(50176, 512)
        self.fc2 = nn.Linear(512, 256)
        self.fc3 = nn.Linear(256, 128)
        self.fc4 = nn.Linear(128, 64)
        self.fc5 = nn.Linear(64, 32)
        self.fc6 = nn.Linear(32, 16)
        self.fc7 = nn.Linear(16, 2)
        self.dropout = nn.Dropout(p=0.2)

    def forward(self, x):
        x = x.view(x.shape[0], -1)
        x = F.relu(self.fc1(x))
        x = self.dropout(x)
        x = F.relu(self.fc2(x))
        x = self.dropout(x)
        x = F.relu(self.fc3(x))
        x = self.dropout(x)
        x = F.relu(self.fc4(x))
        x = self.dropout(x)
        x = F.relu(self.fc5(x))
        x = self.dropout(x)
        x = F.relu(self.fc6(x))
        x = self.dropout(x)
        x = F.log_softmax(self.fc7(x), dim=1)

        return x

model = Classifier()
criterion = nn.NLLLoss()
optimizer = optim.Adam(model.parameters(), lr=0.003)

```

### Model Training

The model is trained for 10 epochs. The loss and accuracy are printed every 5 steps.

```{python}
#| label: train

epochs = 10
steps = 0
running_loss = 0
print_every = 5

for epoch in range(epochs):
    for images, labels in dataloader:
        steps += 1

        optimizer.zero_grad()

        log_ps = model(images)
        loss = criterion(log_ps, labels)
        loss.backward()
        optimizer.step()

        running_loss += loss.item()

        if steps % print_every == 0:
            test_loss = 0
            accuracy = 0
            model.eval()
            with torch.no_grad():
                for images, labels in dataloader:
                    log_ps = model(images)
                    batch_loss = criterion(log_ps, labels)

                    test_loss += batch_loss.item()

                    # Calculate accuracy
                    ps = torch.exp(log_ps)
                    top_p, top_class = ps.topk(1, dim=1)
                    equals = top_class == labels.view(*top_class.shape)
                    accuracy += torch.mean(equals.type(torch.FloatTensor)).item()

            print(f"Epoch {epoch+1}/{epochs}.. "
                  f"Train loss: {running_loss/print_every:.3f}.. "
                  f"Test loss: {test_loss/len(dataloader):.3f}.. "
                  f"Test accuracy: {accuracy/len(dataloader):.3f}")
            running_loss = 0
            model.train()

```

### Model Evaluation

The model is evaluated on the test set.

```{python}
#| label: evaluate

test_loss = 0
accuracy = 0
model.eval()

with torch.no_grad():
    for images, labels in dataloader:
        log_ps = model(images)
        batch_loss = criterion(log_ps, labels)

        test_loss += batch_loss.item()

        # Calculate accuracy
        ps = torch.exp(log_ps)
        top_p, top_class = ps.topk(1, dim=1)
        equals = top_class == labels.view(*top_class.shape)
        accuracy += torch.mean(equals.type(torch.FloatTensor)).item()

print(f"Test loss: {test_loss/len(dataloader):.3f}.. "
      f"Test accuracy: {accuracy/len(dataloader):.3f}")

```

### Predictions

The model is used to predict the class of a single image.

```{python}
#| label: predict

images, labels = next(iter(dataloader))

img = images[0].view(1, 3, 224, 224)

# Turn off gradients to speed up this part
with torch.no_grad():
    logps = model(img)

# Output of the network are log-probabilities, need to take exponential for probabilities
ps = torch.exp(logps)
probab = list(ps.numpy()[0])
print("Predicted Probability:", probab)
print("Predicted Label:", probab.index(max(probab)))

```

### Save and Load Model

The model is saved to a file and then loaded from the file.

```{python}
#| label: save-load-model

torch.save(model.state_dict(), 'model.pth')

model = Classifier()
model.load_state_dict(torch.load('model.pth'))

```

## For more information

* [PyTorch](https://pytorch.org/)
* [PyTorch Tutorials](https://pytorch.org/tutorials/)
* [PyTorch Documentation](https://pytorch.org/docs/stable/index.html)